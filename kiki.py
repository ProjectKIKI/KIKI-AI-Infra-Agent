
#!/usr/bin/env python3
"""
KIKI v2 - Python-based Infra Code Generator with Role Scaffolding

Targets:
  - ansible  : Ansible playbook skeleton OR role scaffolding (layout=playbook|role)
  - openstack: Heat template skeleton
  - k8s      : Kubernetes manifest (Deployment + Service)

LLM 연동은 별도 모듈에서 처리하고,
이 파일은 "입력 파라미터 → YAML/디렉터리 구조"의 기본 뼈대를 제공하는 역할만 합니다.
"""

import argparse
import sys
import subprocess
from pathlib import Path
from typing import Optional


def debug(msg: str):
    print(f"[kiki] {msg}", file=sys.stderr)


# ------------------ 공통 유틸 ------------------ #

def ensure_parent_dir(path: Path):
    if path.parent and not path.parent.exists():
        path.parent.mkdir(parents=True, exist_ok=True)


def write_file(path: Path, content: str):
    ensure_parent_dir(path)
    path.write_text(content, encoding="utf-8")
    debug(f"generated file: {path}")


def which(cmd: str) -> Optional[str]:
    """`cmd`가 PATH 상에 존재하는지 확인."""
    from shutil import which as _which
    return _which(cmd)


# ------------------ 검증 함수 ------------------ #

def validate_k8s(path: Path):
    """kubectl dry-run=server 로 기본 검증 (있을 때만)."""
    if which("kubectl") is None:
        debug("kubectl not found, skip k8s validation.")
        return

    debug(f"validating k8s manifest via kubectl: {path}")
    try:
        subprocess.run(
            ["kubectl", "apply", "--dry-run=server", "-f", str(path)],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            check=True,
        )
        debug("kubectl validation OK")
    except subprocess.CalledProcessError as e:
        print("=== kubectl validation failed ===", file=sys.stderr)
        print(e.stdout.decode(errors="ignore"), file=sys.stderr)
        print(e.stderr.decode(errors="ignore"), file=sys.stderr)


# ------------------ 생성 로직: Ansible (playbook) ------------------ #

def generate_ansible_playbook(args):
    """
    단순한 Ansible 플레이북 스니펫 생성.
    실제 현업에서는 LLM이 `tasks:` 영역을 채우는 용도로 사용하면 됨.
    """
    content = f"""---
- name: Generated playbook by KIKI
  hosts: {args.hosts}
  become: true

  vars:
    app_name: {args.name}

  tasks:
    - name: Example debug
      ansible.builtin.debug:
        msg: "Hello from KIKI for {{ '{{ app_name }}' }}"
"""
    out_path = Path(args.out or "playbook-generated.yml")
    write_file(out_path, content)
    print(out_path)


# ------------------ 생성 로직: Ansible (role scaffolding) ------------------ #

def generate_ansible_role(args):
    """
    Ansible Role 스캐폴딩 생성.

    layout=role 일 때 동작.
    - 기본 디렉터리: roles/<role_name>/...
    - --out 을 지정하면 해당 경로를 roles root 로 사용 (예: --out infra_roles)
    """
    role_name = args.role_name or args.name or "role"
    base_dir = Path(args.out) if args.out else Path("roles")
    role_dir = base_dir / role_name

    # 디렉터리 구조
    tasks_dir = role_dir / "tasks"
    handlers_dir = role_dir / "handlers"
    vars_dir = role_dir / "vars"
    templates_dir = role_dir / "templates"
    meta_dir = role_dir / "meta"

    for d in [tasks_dir, handlers_dir, vars_dir, templates_dir, meta_dir]:
        d.mkdir(parents=True, exist_ok=True)
        debug(f"created directory: {d}")

    # tasks/main.yml
    tasks_main = f"""---
# {role_name} role main tasks
- name: "{role_name} role main task"
  ansible.builtin.debug:
    msg: "TODO: implement {role_name} role tasks"
"""
    write_file(tasks_dir / "main.yml", tasks_main)

    # handlers/main.yml
    handlers_main = f"""---
# handlers for role {role_name}
# - name: reload service
#   ansible.builtin.service:
#     name: your_service
#     state: reloaded
"""
    write_file(handlers_dir / "main.yml", handlers_main)

    # vars/main.yml
    vars_main = f"""---
# default variables for role {role_name}
# example_var: default_value
"""
    write_file(vars_dir / "main.yml", vars_main)

    # meta/main.yml
    meta_main = f"""---
galaxy_info:
  author: kiki
  description: "Role {role_name} generated by KIKI"
  min_ansible_version: "2.16"
dependencies: []
"""
    write_file(meta_dir / "main.yml", meta_main)

    # 옵션: site_<role_name>.yml 생성 (roles와 함께 쓸 수 있는 기본 플레이북)
    hosts = args.role_hosts or "all"
    site_play = f"""---
- name: "Site playbook for role {role_name}"
  hosts: {hosts}
  become: true

  roles:
    - {role_name}
"""
    site_path = base_dir.parent / f"site_{role_name}.yml"
    write_file(site_path, site_play)

    print(f"role_dir={role_dir}")
    print(f"site_play={site_path}")


# ------------------ 생성 로직: OpenStack(Heat) ------------------ #

def generate_openstack(args):
    """
    Heat 템플릿 스켈레톤 생성.
    이후 LLM이 `resources` 및 `outputs`를 세부적으로 채우는 구조.
    """
    content = f"""heat_template_version: 2018-08-31

description: >
  Simple server stack generated by KIKI.
  name={args.name}, image={args.image}, flavor={args.flavor}, network={args.network}

parameters:
  image:
    type: string
    default: "{args.image}"
  flavor:
    type: string
    default: "{args.flavor}"
  network:
    type: string
    default: "{args.network}"

resources:
  server:
    type: OS::Nova::Server
    properties:
      name: "{args.name}"
      image: {{ get_param: image }}
      flavor: {{ get_param: flavor }}
      networks:
        - network: {{ get_param: network }}

outputs:
  server_name:
    description: Name of the created server
    value: {{ get_attr: [server, name] }}
"""
    out_path = Path(args.out or "heat-template-generated.yaml")
    write_file(out_path, content)
    print(out_path)


# ------------------ 생성 로직: Kubernetes ------------------ #

def generate_k8s(args):
    """
    Deployment + Service (ClusterIP) 기본 매니페스트 생성.
    securityContext 등은 최소한만 두고, 이후 LLM이 강화하는 것을 권장.
    """
    ns = args.ns or "default"
    deployment = f"""apiVersion: apps/v1
kind: Deployment
metadata:
  name: {args.name}
  namespace: {ns}
spec:
  replicas: {args.replicas}
  selector:
    matchLabels:
      app: {args.name}
  template:
    metadata:
      labels:
        app: {args.name}
    spec:
      containers:
      - name: {args.name}
        image: {args.image}
        ports:
        - containerPort: {args.port}
"""
    service = f"""---
apiVersion: v1
kind: Service
metadata:
  name: {args.name}
  namespace: {ns}
spec:
  type: ClusterIP
  selector:
    app: {args.name}
  ports:
  - port: {args.port}
    targetPort: {args.port}
"""

    all_yaml = deployment + "\n" + service + "\n"
    out_path = Path(args.out or f"{args.name}-k8s.yaml")
    write_file(out_path, all_yaml)
    print(out_path)

    if args.validate:
        validate_k8s(out_path)


# ------------------ CLI 파서 ------------------ #

def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="kiki",
        description="KIKI - AI Infra Code Generator (ansible / openstack / k8s)",
    )

    sub = parser.add_subparsers(dest="command")

    # gen 서브커맨드
    gen = sub.add_parser("gen", help="Generate infra code (playbook / role / Heat / K8s)")
    gen.add_argument(
        "-t", "--target",
        choices=["ansible", "openstack", "k8s"],
        default="ansible",
        help="generation target (default: ansible)",
    )
    gen.add_argument("--name", "-n", default="demo", help="resource name / app name")
    gen.add_argument("--image", default="nginx:latest", help="container or server image")
    gen.add_argument("--port", type=int, default=80, help="service/container port")
    gen.add_argument("--replicas", type=int, default=1, help="k8s replicas")

    # ansible 전용
    gen.add_argument("--hosts", default="all", help="ansible hosts pattern (layout=playbook)")

    # ansible layout
    gen.add_argument(
        "--layout",
        choices=["playbook", "role"],
        default="playbook",
        help="ansible layout: playbook or role (ansible target 전용)",
    )
    gen.add_argument(
        "--role-name",
        help="layout=role 일 때 역할 이름 (기본값: --name)",
    )
    gen.add_argument(
        "--role-hosts",
        default="all",
        help="layout=role 일 때 자동 생성 site_<role>.yml 의 hosts 값",
    )

    # openstack 전용
    gen.add_argument("--flavor", default="m1.small", help="OpenStack flavor name")
    gen.add_argument("--network", default="public", help="OpenStack network name")

    # k8s 전용
    gen.add_argument("--ns", "--namespace", default="default", help="k8s namespace")
    gen.add_argument(
        "--validate",
        action="store_true",
        help="validate k8s manifest via kubectl dry-run (only when target=k8s)",
    )

    gen.add_argument(
        "--out", "-o",
        help="output path (YAML or roles base dir)",
    )

    gen.set_defaults(func=cmd_gen)
    return parser


def cmd_gen(args):
    if args.target == "ansible":
        if args.layout == "role":
            generate_ansible_role(args)
        else:
            generate_ansible_playbook(args)
    elif args.target == "openstack":
        generate_openstack(args)
    elif args.target == "k8s":
        generate_k8s(args)
    else:
        raise SystemExit(f"Unknown target: {args.target}")


def main(argv=None):
    parser = build_parser()
    args = parser.parse_args(argv)

    if not args.command:
        parser.print_help()
        return 1

    if hasattr(args, "func"):
        return args.func(args)
    else:
        parser.print_help()
        return 1


if __name__ == "__main__":
    raise SystemExit(main())
