
#!/usr/bin/env python3
"""
KIKI v2 - Python-based Infra Code Generator

Targets:
  - ansible  : Ansible playbook skeleton
  - openstack: Heat template skeleton
  - k8s      : Kubernetes manifest (Deployment + Service)

LLM 연동은 별도 모듈에서 처리하고,
이 파일은 "입력 파라미터 → YAML 구조"의 기본 뼈대를 제공하는 역할만 합니다.
"""

import argparse
import os
import sys
import subprocess
from pathlib import Path
from typing import Optional


def debug(msg: str):
    print(f"[kiki] {msg}", file=sys.stderr)


# ------------------ 공통 유틸 ------------------ #

def ensure_parent_dir(path: Path):
    if path.parent and not path.parent.exists():
        path.parent.mkdir(parents=True, exist_ok=True)


def write_file(path: Path, content: str):
    ensure_parent_dir(path)
    path.write_text(content, encoding="utf-8")
    debug(f"generated file: {path}")


def which(cmd: str) -> Optional[str]:
    """`cmd`가 PATH 상에 존재하는지 확인."""
    from shutil import which as _which
    return _which(cmd)


# ------------------ 검증 함수 ------------------ #

def validate_k8s(path: Path):
    """kubectl dry-run=server 로 기본 검증 (있을 때만)."""
    if which("kubectl") is None:
        debug("kubectl not found, skip k8s validation.")
        return

    debug(f"validating k8s manifest via kubectl: {path}")
    try:
        subprocess.run(
            ["kubectl", "apply", "--dry-run=server", "-f", str(path)],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            check=True,
        )
        debug("kubectl validation OK")
    except subprocess.CalledProcessError as e:
        print("=== kubectl validation failed ===", file=sys.stderr)
        print(e.stdout.decode(errors="ignore"), file=sys.stderr)
        print(e.stderr.decode(errors="ignore"), file=sys.stderr)


# ------------------ 생성 로직: Ansible ------------------ #

def generate_ansible(args):
    """
    아주 단순한 Ansible 플레이북 스니펫 생성.
    실제 현업에서는 LLM이 `tasks:` 영역을 채우는 용도로 사용하면 됨.
    """
    content = f"""---
- name: Generated playbook by KIKI
  hosts: {args.hosts}
  become: true

  vars:
    app_name: {args.name}

  tasks:
    - name: Example debug
      ansible.builtin.debug:
        msg: "Hello from KIKI for {{ '{{ app_name }}' }}"
"""
    out_path = Path(args.out or "playbook-generated.yml")
    write_file(out_path, content)
    print(out_path)


# ------------------ 생성 로직: OpenStack(Heat) ------------------ #

def generate_openstack(args):
    """
    Heat 템플릿 스켈레톤 생성.
    이후 LLM이 `resources` 및 `outputs`를 세부적으로 채우는 구조.
    """
    content = f"""heat_template_version: 2018-08-31

description: >
  Simple server stack generated by KIKI.
  name={args.name}, image={args.image}, flavor={args.flavor}, network={args.network}

parameters:
  image:
    type: string
    default: "{args.image}"
  flavor:
    type: string
    default: "{args.flavor}"
  network:
    type: string
    default: "{args.network}"

resources:
  server:
    type: OS::Nova::Server
    properties:
      name: "{args.name}"
      image: {{ get_param: image }}
      flavor: {{ get_param: flavor }}
      networks:
        - network: {{ get_param: network }}

outputs:
  server_name:
    description: Name of the created server
    value: {{ get_attr: [server, name] }}
"""
    out_path = Path(args.out or "heat-template-generated.yaml")
    write_file(out_path, content)
    print(out_path)


# ------------------ 생성 로직: Kubernetes ------------------ #

def generate_k8s(args):
    """
    Deployment + Service (ClusterIP) 기본 매니페스트 생성.
    securityContext 등은 최소한만 두고, 이후 LLM이 강화하는 것을 권장.
    """
    ns = args.ns or "default"
    deployment = f"""apiVersion: apps/v1
kind: Deployment
metadata:
  name: {args.name}
  namespace: {ns}
spec:
  replicas: {args.replicas}
  selector:
    matchLabels:
      app: {args.name}
  template:
    metadata:
      labels:
        app: {args.name}
    spec:
      containers:
      - name: {args.name}
        image: {args.image}
        ports:
        - containerPort: {args.port}
"""
    service = f"""---
apiVersion: v1
kind: Service
metadata:
  name: {args.name}
  namespace: {ns}
spec:
  type: ClusterIP
  selector:
    app: {args.name}
  ports:
  - port: {args.port}
    targetPort: {args.port}
"""

    all_yaml = deployment + "\n" + service + "\n"
    out_path = Path(args.out or f"{args.name}-k8s.yaml")
    write_file(out_path, all_yaml)
    print(out_path)

    if args.validate:
        validate_k8s(out_path)


# ------------------ CLI 파서 ------------------ #

def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="kiki",
        description="KIKI - AI Infra Code Generator (ansible / openstack / k8s)",
    )

    sub = parser.add_subparsers(dest="command")

    # gen 서브커맨드
    gen = sub.add_parser("gen", help="Generate infra code")
    gen.add_argument(
        "-t", "--target",
        choices=["ansible", "openstack", "k8s"],
        default="ansible",
        help="generation target (default: ansible)",
    )
    gen.add_argument("--name", "-n", default="demo", help="resource name / app name")
    gen.add_argument("--image", default="nginx:latest", help="container or server image")
    gen.add_argument("--port", type=int, default=80, help="service/container port")
    gen.add_argument("--replicas", type=int, default=1, help="k8s replicas")

    # ansible 전용
    gen.add_argument("--hosts", default="all", help="ansible hosts pattern")

    # openstack 전용
    gen.add_argument("--flavor", default="m1.small", help="OpenStack flavor name")
    gen.add_argument("--network", default="public", help="OpenStack network name")

    # k8s 전용
    gen.add_argument("--ns", "--namespace", default="default", help="k8s namespace")
    gen.add_argument(
        "--validate",
        action="store_true",
        help="validate k8s manifest via kubectl dry-run (only when target=k8s)",
    )

    gen.add_argument(
        "--out", "-o",
        help="output path (YAML)",
    )

    gen.set_defaults(func=cmd_gen)
    return parser


def cmd_gen(args):
    if args.target == "ansible":
        generate_ansible(args)
    elif args.target == "openstack":
        generate_openstack(args)
    elif args.target == "k8s":
        generate_k8s(args)
    else:
        raise SystemExit(f"Unknown target: {args.target}")


def main(argv=None):
    parser = build_parser()
    args = parser.parse_args(argv)

    if not args.command:
        parser.print_help()
        return 1

    if hasattr(args, "func"):
        return args.func(args)
    else:
        parser.print_help()
        return 1


if __name__ == "__main__":
    raise SystemExit(main())
