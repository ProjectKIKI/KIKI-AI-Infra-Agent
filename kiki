#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
KIKI v3 - Infra Code / YAML / Playbook Generator CLI

명령 요약:

  kiki chat "일반 대화"

  kiki ansible-ai "자연어 설명" \
    --target ansible|k8s|osp|heat \
    --base-url http://127.0.0.1:8082 \
    --model local-llama \
    --inventory "node1,node2,node3" \
    --verify all \
    --out playbooks/httpd.yml \
    --confirm

  # alias
  kiki ansible-k8s "자연어"   # = ansible-ai --target k8s
  kiki ansible-osp "자연어"   # = ansible-ai --target osp

  kiki gen-role --name web --confirm
  kiki gen-k8s --name web --image nginx:1.27 --port 80 --replicas 3 --namespace demo --out k8s/web.yaml --validate --confirm

  kiki gen-heat --name demo-stack --out heat/demo.yaml --confirm

  kiki yaml-ai "자연어 설명" \
    --mode yaml-k8s|yaml-osp \
    --base-url http://127.0.0.1:8082 \
    --model local-llama \
    --verify syntax \
    --out k8s/demo.yaml \
    --confirm

"""

import argparse
import sys
import os
import re
from pathlib import Path
import textwrap
import json
from typing import Optional
import subprocess
import shlex

# optional deps
try:
    import requests  # type: ignore
except ImportError:
    requests = None

try:
    import yaml  # type: ignore
except ImportError:
    yaml = None


# ─────────────────────────────────────────────
# 공용 유틸
# ─────────────────────────────────────────────

def debug_print(enabled: bool, msg: str) -> None:
    if enabled:
        print(f"[DEBUG] {msg}", file=sys.stderr)


def read_stdin_all() -> str:
    """
    stdin에서 전체 텍스트를 읽는다 (파이프/리다이렉트 대응).
    """
    return sys.stdin.read()


def read_prompt_from_args_or_stdin(prompt: Optional[str], message: Optional[str]) -> str:
    """
    - prompt 인자를 우선 사용
    - 없으면 message 사용
    - 둘 다 없고 stdin이 파이프라면 stdin 사용
    """
    if prompt:
        return prompt
    if message:
        return message

    if not sys.stdin.isatty():
        data = read_stdin_all().strip()
        if data:
            return data

    print("[ERROR] 자연어 프롬프트가 비어 있습니다. 인자 또는 stdin으로 입력해 주세요.", file=sys.stderr)
    sys.exit(1)


def confirm_action(prompt: str) -> bool:
    """
    yes/no 확인을 받는 공용 함수.
    """
    while True:
        ans = input(f"{prompt} [y/N]: ").strip().lower()
        if ans in ("y", "yes"):
            return True
        if ans in ("n", "no", ""):
            return False
        print("y 또는 n으로 입력해 주세요.", file=sys.stderr)


def write_file(path: Path, content: str, force: bool = False, debug_enabled: bool = False) -> None:
    """
    path에 content를 기록 (기존 파일이 있으면 force가 아니면 에러).
    """
    path = path.expanduser()
    if path.exists() and not force:
        print(f"[ERROR] 파일이 이미 존재합니다: {path} (덮어쓰려면 --force 사용)", file=sys.stderr)
        sys.exit(1)

    debug_print(debug_enabled, f"writing file: {path}")
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")
    print(f"[INFO] 파일 저장 완료: {path}")


def load_yaml_for_verify(content: str) -> bool:
    """
    YAML 문법 검증.
    - 여러 개의 문서(---로 구분된 multi-document)도 허용한다.
    """
    if yaml is None:
        print("[WARN] PyYAML이 설치되어 있지 않아 로컬 YAML 검증을 건너뜁니다.", file=sys.stderr)
        return True

    try:
        # safe_load_all 로 여러 문서 처리
        docs = list(yaml.safe_load_all(content))

        # 빈 문서만 있는 경우 경고 정도만
        if all(d is None for d in docs):
            print("[WARN] YAML 문서가 비어 있습니다.", file=sys.stderr)

        return True
    except Exception as e:
        print(f"[ERROR] YAML 파싱 오류: {e}", file=sys.stderr)
        return False


def strip_markdown_fences(text: str) -> str:
    """
    ```yaml ... ``` 형태의 마크다운 코드 블록 펜스를 제거.
    """
    # ```yaml\n...\n``` 또는 ```\n...\n``` 케이스를 모두 제거
    fence_pattern = re.compile(r"```[a-zA-Z0-9_]*\n(.*?)```", re.DOTALL)
    m = fence_pattern.search(text)
    if m:
        return m.group(1).strip()
    # fallback: 그냥 ``` 만 제거
    return text.replace("```yaml", "").replace("```yml", "").replace("```", "").strip()


def extract_yaml_from_text(text: str) -> str:
    """
    LLM 응답에서 YAML처럼 보이는 부분만 추출.
    - '---'로 시작하는 블록 또는 'heat_template_version:' 등 기준으로.
    """
    lines = text.splitlines()
    # 우선 'heat_template_version:' 있는 라인부터 끝까지
    for i, line in enumerate(lines):
        if line.strip().startswith("heat_template_version:"):
            return "\n".join(lines[i:]).strip()

    # '---' 로 시작하는 라인 찾기
    start_idx = None
    for i, line in enumerate(lines):
        if line.strip().startswith("---"):
            start_idx = i
            break

    if start_idx is not None:
        return "\n".join(lines[start_idx:]).strip()

    # fallback: 그냥 전체 반환
    return text


def call_llm_chat(
    base_url: str,
    model: str,
    system_prompt: str,
    user_prompt: str,
    api_key: Optional[str] = None,
    debug_enabled: bool = False,
) -> str:
    """
    매우 단순한 OpenAI 호환 /v1/chat/completions 호출.
    """
    if requests is None:
        print("[ERROR] requests 라이브러리가 필요합니다. (pip install requests)", file=sys.stderr)
        sys.exit(1)

    url = base_url.rstrip("/") + "/v1/chat/completions"
    headers = {"Content-Type": "application/json"}
    if api_key:
        headers["Authorization"] = f"Bearer {api_key}"

    payload = {
        "model": model,
        "messages": [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt},
        ],
        "temperature": 0.1,
    }

    debug_print(debug_enabled, f"POST {url}")
    debug_print(debug_enabled, "system_prompt:\n" + system_prompt)
    debug_print(debug_enabled, "user_prompt:\n" + user_prompt)

    resp = requests.post(url, headers=headers, json=payload, timeout=600)
    if resp.status_code != 200:
        print(f"[ERROR] LLM API 호출 실패: HTTP {resp.status_code} {resp.text}", file=sys.stderr)
        sys.exit(1)

    data = resp.json()
    try:
        content = data["choices"][0]["message"]["content"]
    except Exception:
        print(f"[ERROR] LLM 응답 파싱 실패: {data}", file=sys.stderr)
        sys.exit(1)

    debug_print(debug_enabled, "LLM raw response:\n" + content)
    return content


# ─────────────────────────────────────────────
# chat
# ─────────────────────────────────────────────

def cmd_chat(args: argparse.Namespace) -> None:
    debug_enabled = args.debug

    base_url = args.base_url or os.environ.get("KIKI_LLM_BASE_URL", "http://127.0.0.1:8082")
    model = args.model or os.environ.get("KIKI_LLM_MODEL", "local-model")
    api_key = args.api_key or os.environ.get("KIKI_LLM_API_KEY")

    user_prompt = read_prompt_from_args_or_stdin(args.prompt, args.message)
    system_prompt = args.system or "You are a helpful infra/DevOps assistant."

    reply = call_llm_chat(
        base_url=base_url,
        model=model,
        system_prompt=system_prompt,
        user_prompt=user_prompt,
        api_key=api_key,
        debug_enabled=debug_enabled,
    )

    print(reply)


# ─────────────────────────────────────────────
# ansible-ai (+ alias)
# ─────────────────────────────────────────────


# ─────────────────────────────────────────────
# yaml-ai (pure YAML generator for K8s / Heat)
# ─────────────────────────────────────────────

def build_yaml_ai_system_prompt(mode: str, verify: str) -> str:
    """yaml-k8s / yaml-osp 용 순수 YAML 생성 system prompt."""
    if mode == "yaml-k8s":
        base = textwrap.dedent("""
        You are an expert Kubernetes YAML manifest author.
        - Output ONLY valid Kubernetes YAML manifests. No markdown, no explanations.
        - You may output multiple Kubernetes resources separated by '---'.
        - Each resource must include proper apiVersion, kind, metadata, and spec.
        - Never wrap the YAML in any markdown code fences such as triple backticks.
        - The output MUST start with a YAML document (optionally starting with '---').
        """)
    elif mode == "yaml-osp":
        base = textwrap.dedent("""
        You are an expert OpenStack Heat template author.
        - Output ONLY a single valid Heat template in YAML. No markdown, no explanations.
        - The template should include heat_template_version, description, parameters, resources,
          and outputs if appropriate.
        - Never wrap the YAML in any markdown code fences such as triple backticks.
        - The output MUST start with 'heat_template_version:' on the first line.
        """)
    else:
        base = "You are an infrastructure YAML generator. Output only valid YAML."

    if verify in ("syntax", "all"):
        base += "\n- The YAML must be syntactically valid.\n"

    if verify == "all":
        base += "\n- Use production-grade best practices for this kind of resource.\n"

    return base.strip()

def build_ansible_ai_system_prompt(target: str, verify: str, inventory: Optional[str]) -> str:
    base = ""

    if target == "ansible":
        base = textwrap.dedent("""
        You are an expert Ansible Playbook generator.
        - Output ONLY valid Ansible YAML. No markdown, no explanations.
        - The top-level must be a list of plays.
        - Use idempotent ansible.builtin modules whenever possible.
        - Never wrap the YAML in any markdown code fences such as triple backticks.
        - The output MUST start with a line containing only '---'.
        """)
    elif target == "k8s":
        base = textwrap.dedent("""
        You are an expert Ansible Playbook generator for Kubernetes.
        - Output ONLY valid Ansible YAML. No markdown, no explanations.
        - Use kubernetes.core collection modules (k8s, k8s_info, etc.).
        - The playbook should apply Kubernetes resources based on the user request.
        - Never wrap the YAML in any markdown code fences such as triple backticks.
        - The output MUST start with a line containing only '---'.
        """)
    elif target == "osp":
        base = textwrap.dedent("""
        You are an expert Ansible Playbook generator for OpenStack.
        - Output ONLY valid Ansible YAML. No markdown, no explanations.
        - Use openstack.cloud collection modules, not legacy os_* modules.
        - Never wrap the YAML in any markdown code fences such as triple backticks.
        - The output MUST start with a line containing only '---'.
        """)
    elif target == "heat":
        base = textwrap.dedent("""
        You are an expert OpenStack Heat template author.
        - Output ONLY valid YAML for a single Heat template (no markdown, no explanations).
        - Include heat_template_version, description, parameters, resources, and outputs if appropriate.
        - Never wrap the YAML in any markdown code fences such as triple backticks.
        - The output MUST start with 'heat_template_version:' on the first line.
        """)
    else:
        base = "You are an infrastructure as code generator. Output only valid YAML."

    if verify in ("syntax", "all"):
        base += "\n- The YAML must be syntactically valid.\n"

    if verify == "all":
        base += "\n- Make playbooks idempotent and use best practices.\n"

    if inventory:
        base += f"\n- Inventory context (host names or groups): {inventory}\n"

    return base.strip()


def cmd_ansible_ai(args: argparse.Namespace) -> None:
    # target: ansible | k8s | osp | heat
    target = getattr(args, "target", None) or getattr(args, "ansible_target", "ansible")
    verify = args.verify
    inventory = args.inventory
    debug_enabled = args.debug

    base_url = args.base_url or os.environ.get("KIKI_LLM_BASE_URL", "http://127.0.0.1:8082")
    model = args.model or os.environ.get("KIKI_LLM_MODEL", "local-model")
    api_key = args.api_key or os.environ.get("KIKI_LLM_API_KEY")

    user_prompt = read_prompt_from_args_or_stdin(args.prompt, args.message)

    system_prompt = build_ansible_ai_system_prompt(target, verify, inventory)

    # user_prompt에 옵션 컨텍스트 추가
    extra = []
    if inventory:
        extra.append(f"Inventory: {inventory}")
    if target in ("ansible", "k8s", "osp"):
        extra.append("결과는 Ansible playbook 전체 YAML로 출력해줘.")
    elif target == "heat":
        extra.append("결과는 Heat 템플릿 YAML 한 개만 출력해줘.")

    if extra:
        user_prompt = user_prompt + "\n\n[Context]\n" + "\n".join(extra)

    yaml_text_raw = call_llm_chat(
        base_url=base_url,
        model=model,
        system_prompt=system_prompt,
        user_prompt=user_prompt,
        api_key=api_key,
        debug_enabled=debug_enabled,
    )

    # 1차 방어: ``` 코드 블록 펜스 제거
    yaml_text_clean = strip_markdown_fences(yaml_text_raw)

    # 2차 방어: 설명/문장 제거하고 YAML 부분만 추출
    yaml_text = extract_yaml_from_text(yaml_text_clean)

    # verify 옵션 처리
    if verify in ("syntax", "all"):
        ok = load_yaml_for_verify(yaml_text)
        if not ok:
            print("[ERROR] YAML 검증에 실패했습니다. 위 오류를 확인하세요.", file=sys.stderr)
            sys.exit(1)

    # 실행 전 확인
    if args.confirm:
        print("========== 생성된 YAML (preview) ==========")
        print(yaml_text)
        print("===========================================")
        if not confirm_action("이 내용을 출력/저장할까요?"):
            print("[INFO] 사용자 취소로 작업 중단됨.")
            sys.exit(0)

    # 출력 처리
    if args.out:
        out_path = Path(args.out)
        write_file(out_path, yaml_text, force=args.force, debug_enabled=debug_enabled)
    else:
        print(yaml_text)

    # ─────────────────────────────────────────
    # --apply: 생성 직후 ansible-playbook 실행
    # ─────────────────────────────────────────
    if getattr(args, "apply", False):
        if target == "heat":
            print("[ERROR] --apply는 Heat 템플릿(target=heat)에서는 지원하지 않습니다.", file=sys.stderr)
            sys.exit(1)

        if not args.out:
            print("[ERROR] --apply를 사용하려면 --out으로 플레이북 파일 경로를 지정해야 합니다.", file=sys.stderr)
            sys.exit(1)

        if not args.inventory:
            print("[ERROR] --apply를 사용하려면 --inventory에 Ansible 인벤토리를 지정해야 합니다.", file=sys.stderr)
            sys.exit(1)

        out_path = Path(args.out)
        inv = args.inventory

        cmd = ["ansible-playbook", "-i", inv, str(out_path)]
        debug_print(debug_enabled, "실행 명령: " + " ".join(shlex.quote(c) for c in cmd))

        try:
            result = subprocess.run(cmd)
        except FileNotFoundError:
            print("[ERROR] ansible-playbook 명령을 찾을 수 없습니다. Ansible이 설치되어 있는지 확인하세요.", file=sys.stderr)
            sys.exit(1)

        if result.returncode != 0:
            print(f"[ERROR] ansible-playbook 실행이 실패했습니다. (exit={result.returncode})", file=sys.stderr)
            sys.exit(result.returncode)



def cmd_yaml_ai(args: argparse.Namespace) -> None:
    """자연어 → 순수 Kubernetes / Heat YAML 생성 (옵션: yaml-k8s, yaml-osp)"""
    mode = args.mode          # yaml-k8s | yaml-osp
    verify = args.verify      # none | syntax | all
    debug_enabled = args.debug

    base_url = args.base_url or os.environ.get("KIKI_LLM_BASE_URL", "http://127.0.0.1:8082")
    model = args.model or os.environ.get("KIKI_LLM_MODEL", "local-model")
    api_key = args.api_key or os.environ.get("KIKI_LLM_API_KEY")

    # 자연어 프롬프트 읽기
    user_prompt = read_prompt_from_args_or_stdin(args.prompt, args.message)

    # system prompt 구성
    system_prompt = build_yaml_ai_system_prompt(mode, verify)

    # 모드별 한글 컨텍스트 추가
    extra: list[str] = []

    if mode == "yaml-k8s":
        extra.append("결과는 Kubernetes 리소스 매니페스트의 순수 YAML로만 출력해줘.")
        extra.append("여러 리소스를 생성할 수 있으며, 각 리소스는 '---'로 구분해줘.")
        extra.append("각 리소스는 apiVersion, kind, metadata, spec를 포함해야 해.")
    elif mode == "yaml-osp":
        extra.append("결과는 하나의 OpenStack Heat 템플릿 YAML만 출력해줘.")
        extra.append("heat_template_version, description, parameters, resources, outputs를 포함해줘.")
    else:
        extra.append("결과는 순수 YAML만 출력해줘.")

    extra.append("마크다운 코드 블록(``` 같은 것)은 절대 사용하지 마.")
    extra.append("설명 문장 없이 YAML만 출력해줘.")

    if extra:
        user_prompt = user_prompt + "\n\n[Context]\n" + "\n".join(extra)

    # LLM 호출
    yaml_text_raw = call_llm_chat(
        base_url=base_url,
        model=model,
        system_prompt=system_prompt,
        user_prompt=user_prompt,
        api_key=api_key,
        debug_enabled=debug_enabled,
    )

    yaml_text = strip_markdown_fences(yaml_text_raw).strip()

    # YAML 검증
    if verify in ("syntax", "all"):
        ok = load_yaml_for_verify(yaml_text)
        if not ok:
            print("[ERROR] YAML 파싱 실패: 위 오류를 확인하세요.", file=sys.stderr)
            sys.exit(1)

    # 콘솔에서 썼고 --confirm 이면 미리보기 후 확인
    if args.confirm and sys.stdout.isatty():
        print("===== 생성된 YAML (preview) =====")
        print(yaml_text)
        print("================================")
        if not confirm_action("이 내용을 출력/저장할까요?"):
            print("[INFO] 사용자 취소로 작업 중단됨.")
            sys.exit(0)

    # 출력 처리
    if args.out:
        out_path = Path(args.out)
        write_file(out_path, yaml_text, force=args.force, debug_enabled=debug_enabled)
    else:
        print(yaml_text)

    # ─────────────────────────────────────────
    # --apply: 생성 직후 kubectl apply 실행
    # ─────────────────────────────────────────
    if getattr(args, "apply", False):
        if mode != "yaml-k8s":
            print("[ERROR] --apply는 현재 yaml-k8s 모드에서만 지원됩니다.", file=sys.stderr)
            sys.exit(1)

        debug_print(debug_enabled, "--apply: kubectl apply 실행 준비")

        if args.out:
            manifest_path = Path(args.out)
            cmd = ["kubectl", "apply", "-f", str(manifest_path)]
            debug_print(debug_enabled, "실행 명령: " + " ".join(shlex.quote(c) for c in cmd))
            try:
                result = subprocess.run(cmd)
            except FileNotFoundError:
                print("[ERROR] kubectl 명령을 찾을 수 없습니다. PATH를 확인해 주세요.", file=sys.stderr)
                sys.exit(1)
        else:
            cmd = ["kubectl", "apply", "-f", "-"]
            debug_print(debug_enabled, "실행 명령 (stdin): " + " ".join(shlex.quote(c) for c in cmd))
            try:
                result = subprocess.run(cmd, input=yaml_text.encode("utf-8"))
            except FileNotFoundError:
                print("[ERROR] kubectl 명령을 찾을 수 없습니다. PATH를 확인해 주세요.", file=sys.stderr)
                sys.exit(1)

        if result.returncode != 0:
            print(f"[ERROR] kubectl apply 실패 (exit={result.returncode})", file=sys.stderr)
            sys.exit(resultreturncode)



# ─────────────────────────────────────────────
# gen-role (Ansible role scaffolding)
# ─────────────────────────────────────────────

def cmd_gen_role(args: argparse.Namespace) -> None:
    name = args.name
    roles_dir = Path(args.roles_dir).expanduser() if args.roles_dir else Path.cwd() / "roles"
    debug_enabled = args.debug

    base_dir = roles_dir / name

    if args.confirm:
        if not confirm_action(f"roles/{name}/ 역할 스캐폴딩을 생성할까요?"):
            print("[INFO] 사용자 취소로 작업 중단됨.")
            sys.exit(0)

    # 디렉토리 구조 생성
    paths = [
        base_dir / "tasks" / "main.yml",
        base_dir / "handlers" / "main.yml",
        base_dir / "vars" / "main.yml",
        base_dir / "defaults" / "main.yml",
        base_dir / "meta" / "main.yml",
        base_dir / "templates",
        base_dir / "files",
    ]

    for p in paths:
        if p.suffix:  # 파일
            p.parent.mkdir(parents=True, exist_ok=True)
            if not p.exists():
                p.write_text(textwrap.dedent("""\
                    ---
                    # TODO: role 내용 추가
                    """), encoding="utf-8")
        else:
            p.mkdir(parents=True, exist_ok=True)

    # meta/main.yml 기본 내용
    meta_main = base_dir / "meta" / "main.yml"
    if meta_main.exists() and meta_main.read_text(encoding="utf-8").strip() == "---":
        meta_main.write_text(textwrap.dedent(f"""\
            ---
            galaxy_info:
              author: your-name
              description: Role {name}
              min_ansible_version: 2.9
            dependencies: []
            """), encoding="utf-8")

    print(f"[INFO] Ansible role 스캐폴딩 생성 완료: {base_dir}")


# ─────────────────────────────────────────────
# gen-k8s (Kubernetes Deployment + Service)
# ─────────────────────────────────────────────

def cmd_gen_k8s(args: argparse.Namespace) -> None:
    name = args.name
    image = args.image
    port = args.port
    replicas = args.replicas
    namespace = args.namespace
    debug_enabled = args.debug

    deployment = textwrap.dedent(f"""\
        ---
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: {name}
          namespace: {namespace}
        spec:
          replicas: {replicas}
          selector:
            matchLabels:
              app: {name}
          template:
            metadata:
              labels:
                app: {name}
            spec:
              containers:
                - name: {name}
                  image: {image}
                  ports:
                    - containerPort: {port}
        """)

    service = textwrap.dedent(f"""\
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: {name}
          namespace: {namespace}
        spec:
          type: ClusterIP
          selector:
            app: {name}
          ports:
            - port: {port}
              targetPort: {port}
        """)

    content = deployment + "\n" + service

    if args.validate:
        if not load_yaml_for_verify(content):
            print("[ERROR] gen-k8s가 생성한 YAML 검증 실패", file=sys.stderr)
            sys.exit(1)

    if args.confirm:
        print("========== 생성될 K8s YAML (preview) ==========")
        print(content)
        print("===============================================")
        if not confirm_action("이 내용을 출력/저장할까요?"):
            print("[INFO] 사용자 취소로 작업 중단됨.")
            sys.exit(0)

    if args.out:
        out_path = Path(args.out)
        write_file(out_path, content, force=args.force, debug_enabled=debug_enabled)
    else:
        print(content)
        out_path = None  # stdout 출력만 했을 때 표시용

    # ─────────────────────────────────────────
    # --apply: 즉시 kubectl apply 실행
    # ─────────────────────────────────────────
    if getattr(args, "apply", False):
        debug_print(debug_enabled, "--apply: kubectl apply 실행 준비")

        if args.out:
            manifest_path = Path(args.out)
            cmd = ["kubectl", "apply", "-f", str(manifest_path)]
            debug_print(debug_enabled, "실행 명령: " + " ".join(shlex.quote(c) for c in cmd))
            try:
                result = subprocess.run(cmd)
            except FileNotFoundError:
                print("[ERROR] kubectl 명령을 찾을 수 없습니다. PATH를 확인해 주세요.", file=sys.stderr)
                sys.exit(1)
        else:
            cmd = ["kubectl", "apply", "-f", "-"]
            debug_print(debug_enabled, "실행 명령 (stdin): " + " ".join(shlex.quote(c) for c in cmd))
            try:
                result = subprocess.run(cmd, input=content.encode("utf-8"))
            except FileNotFoundError:
                print("[ERROR] kubectl 명령을 찾을 수 없습니다. PATH를 확인해 주세요.", file=sys.stderr)
                sys.exit(1)

        if result.returncode != 0:
            print(f"[ERROR] kubectl apply 실패 (exit={resultreturncode})", file=sys.stderr)
            sys.exit(result.returncode)



# ─────────────────────────────────────────────
# gen-heat (Heat 템플릿 스캐폴딩)
# ─────────────────────────────────────────────

def cmd_gen_heat(args: argparse.Namespace) -> None:
    name = args.name
    debug_enabled = args.debug

    content = textwrap.dedent(f"""\
    heat_template_version: 2021-04-16

    description: >
      Auto-generated Heat template for {name}
      KIKI가 생성한 YAML-only 템플릿입니다.

    parameters:
      image:
        type: string
        description: Glance image name or ID
      flavor:
        type: string
        description: Nova flavor name
      network:
        type: string
        description: Neutron network name or ID

    resources:
      {name}_server:
        type: OS::Nova::Server
        properties:
          name: {name}
          image: {{ get_param: image }}
          flavor: {{ get_param: flavor }}
          networks:
            - network: {{ get_param: network }}

    outputs:
      server_name:
        description: Created server name
        value: {{ get_attr: [{name}_server, name] }}
    """)

    if args.confirm:
        print("========== 생성될 Heat 템플릿 (preview) ==========")
        print(content)
        print("===============================================")
        if not confirm_action("이 내용을 출력/저장할까요?"):
            print("[INFO] 사용자 취소로 작업 중단됨.")
            sys.exit(0)

    if args.out:
        out_path = Path(args.out)
        write_file(out_path, content, force=args.force, debug_enabled=debug_enabled)
    else:
        print(content)
        out_path = None

    # ─────────────────────────────────────────
    # --apply: openstack stack create 실행
    # ─────────────────────────────────────────
    if getattr(args, "apply", False):
        if not args.out:
            print("[ERROR] gen-heat에서 --apply를 사용하려면 --out으로 템플릿 파일 경로를 지정해야 합니다.", file=sys.stderr)
            sys.exit(1)

        stack_name = args.name
        template_path = Path(args.out)

        cmd = ["openstack", "stack", "create", stack_name, "-t", str(template_path)]
        debug_print(debug_enabled, "실행 명령: " + " ".join(shlex.quote(c) for c in cmd))

        try:
            result = subprocess.run(cmd)
        except FileNotFoundError:
            print("[ERROR] openstack 명령을 찾을 수 없습니다. OpenStack CLI 설치 및 환경 변수를 확인하세요.", file=sys.stderr)
            sys.exit(1)

        if result.returncode != 0:
            print(f"[ERROR] openstack stack create 실패 (exit={result.returncode})", file=sys.stderr)
            sys.exit(result.returncode)



# ─────────────────────────────────────────────
# argparse 빌더
# ─────────────────────────────────────────────

def add_llm_common_args(p: argparse.ArgumentParser) -> None:
    p.add_argument(
        "--base-url",
        help="LLM 서버 base URL (기본: env KIKI_LLM_BASE_URL 또는 http://127.0.0.1:8082)",
    )
    p.add_argument(
        "--model",
        help="LLM 모델 이름 (기본: env KIKI_LLM_MODEL 또는 local-model)",
    )
    p.add_argument(
        "--api-key",
        help="LLM API 키 (필요 시)",
    )


def add_prompt_args(p: argparse.ArgumentParser) -> None:
    p.add_argument(
        "prompt",
        nargs="?",
        help="자연어 프롬프트 (생략 시 --message 또는 stdin 사용)",
    )
    p.add_argument(
        "--message",
        help="자연어 프롬프트 (prompt와 동일, 스크립트 호출용)",
    )


def add_common_flags(p: argparse.ArgumentParser) -> None:
    p.add_argument(
        "--debug",
        action="store_true",
        help="디버그 메시지 출력",
    )
    p.add_argument(
        "--force",
        action="store_true",
        help="기존 파일 덮어쓰기 허용",
    )
    p.add_argument(
        "--confirm",
        action="store_true",
        help="실행 전 사용자 확인 (preview 출력)",
    )


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="kiki",
        description="KIKI v3 - Infra Code / YAML / Playbook Generator CLI",
        formatter_class=argparse.RawTextHelpFormatter,
    )

    subparsers = parser.add_subparsers(dest="command")

    # chat
    p_chat = subparsers.add_parser(
        "chat",
        help="LLM 일반 대화",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    add_common_flags(p_chat)
    add_prompt_args(p_chat)
    add_llm_common_args(p_chat)
    p_chat.add_argument(
        "--system",
        help="system prompt (기본: infra/DevOps 도우미)",
    )
    p_chat.set_defaults(func=cmd_chat)

    # ansible-ai (메인 자연어 → 코드 엔진)
    p_ai = subparsers.add_parser(
        "ansible-ai",
        help="자연어 → Ansible / OpenStack / Kubernetes / Heat YAML 생성",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    add_common_flags(p_ai)
    add_prompt_args(p_ai)
    add_llm_common_args(p_ai)
    p_ai.add_argument(
        "--target",
        choices=["ansible", "k8s", "osp", "heat"],
        default="ansible",
        help="생성 대상 (Ansible, Kubernetes용 Ansible, OpenStack용 Ansible, Heat 템플릿)",
    )
    p_ai.add_argument(
        "--inventory",
        help="인벤토리 정보 (호스트/그룹 이름 등, LLM 힌트용)",
    )
    p_ai.add_argument(
        "--verify",
        choices=["none", "syntax", "all"],
        default="none",
        help="출력 YAML 검증 수준 (none|syntax|all)",
    )
    p_ai.add_argument(
        "--out",
        help="결과 YAML을 저장할 파일 경로 (생략 시 stdout으로 출력)",
    )
    p_ai.add_argument(
        "--apply",
        action="store_true",
        help="생성 후 ansible-playbook으로 즉시 실행 (--out, --inventory 필요, Heat 제외)",
    )
    p_ai.set_defaults(func=cmd_ansible_ai)

    # ansible-k8s (alias)
    p_ai_k8s = subparsers.add_parser(
        "ansible-k8s",
        help="자연어 → Kubernetes용 Ansible 플레이북 (alias: ansible-ai --target k8s)",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    add_common_flags(p_ai_k8s)
    add_prompt_args(p_ai_k8s)
    add_llm_common_args(p_ai_k8s)
    p_ai_k8s.add_argument(
        "--inventory",
        help="인벤토리 정보",
    )
    p_ai_k8s.add_argument(
        "--verify",
        choices=["none", "syntax", "all"],
        default="none",
        help="출력 YAML 검증 수준",
    )
    p_ai_k8s.add_argument(
        "--out",
        help="결과 YAML 파일 경로",
    )

    p_ai_k8s.add_argument(
        "--apply",
        action="store_true",
        help="생성 후 ansible-playbook으로 즉시 실행 (--out, --inventory 필요)",
    )
    p_ai_k8s.set_defaults(func=cmd_ansible_ai, ansible_target="k8s")

    # ansible-osp (alias)
    p_ai_osp = subparsers.add_parser(
        "ansible-osp",
        help="자연어 → OpenStack용 Ansible 플레이북 (alias: ansible-ai --target osp)",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    add_common_flags(p_ai_osp)
    add_prompt_args(p_ai_osp)
    add_llm_common_args(p_ai_osp)
    p_ai_osp.add_argument(
        "--inventory",
        help="인벤토리 정보",
    )
    p_ai_osp.add_argument(
        "--verify",
        choices=["none", "syntax", "all"],
        default="none",
        help="출력 YAML 검증 수준",
    )
    p_ai_osp.add_argument(
        "--out",
        help="결과 YAML 파일 경로",
    )
    p_ai_osp.add_argument(
        "--apply",
        action="store_true",
        help="생성 후 ansible-playbook으로 즉시 실행 (--out, --inventory 필요)",
    )
    p_ai_osp.set_defaults(func=cmd_ansible_ai, ansible_target="osp")


    # yaml-ai (자연어 → 순수 YAML 생성)
    p_yaml = subparsers.add_parser(
        "yaml-ai",
        help="자연어 → 순수 Kubernetes/Heat YAML 생성",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    add_common_flags(p_yaml)
    add_prompt_args(p_yaml)
    add_llm_common_args(p_yaml)
    p_yaml.add_argument(
        "--mode",
        choices=["yaml-k8s", "yaml-osp"],
        default="yaml-k8s",
        help="생성할 YAML 종류 (yaml-k8s: Kubernetes, yaml-osp: OpenStack Heat)",
    )
    p_yaml.add_argument(
        "--verify",
        choices=["none", "syntax", "all"],
        default="syntax",
        help="출력 YAML 검증 수준 (none|syntax|all)",
    )
    p_yaml.add_argument(
        "--out",
        help="결과 YAML을 저장할 파일 경로 (생략 시 stdout으로 출력)",
    )

    p_yaml.add_argument(
        "--apply",
        action="store_true",
        help="생성 후 kubectl apply -f 로 바로 적용 (현재 yaml-k8s 모드만 지원)",
    )
    p_yaml.set_defaults(func=cmd_yaml_ai)
    # gen-role
    p_role = subparsers.add_parser(
        "gen-role",
        help="Ansible role 스캐폴딩 생성 (roles/<name>/ 구조)",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    add_common_flags(p_role)
    p_role.add_argument(
        "--name",
        required=True,
        help="role 이름 (roles/<name>/)",
    )
    p_role.add_argument(
        "--roles-dir",
        help="roles 디렉토리 기본 경로 (기본: ./roles)",
    )
    p_role.set_defaults(func=cmd_gen_role)

    # gen-k8s
    p_k8s = subparsers.add_parser(
        "gen-k8s",
        help="Kubernetes Deployment + Service YAML 스캐폴딩 생성",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    add_common_flags(p_k8s)
    p_k8s.add_argument("--name", required=True, help="Deployment/Service 이름")
    p_k8s.add_argument("--image", required=True, help="컨테이너 이미지")
    p_k8s.add_argument("--port", type=int, default=80, help="서비스/컨테이너 포트 (기본: 80)")
    p_k8s.add_argument("--replicas", type=int, default=1, help="Replica 수 (기본: 1)")
    p_k8s.add_argument("--namespace", dest="namespace", default="default", help="Namespace (기본: default)")
    p_k8s.add_argument("--out", help="출력 파일 경로 (생략 시 stdout)")
    p_k8s.add_argument(
        "--validate",
        action="store_true",
        help="생성된 YAML 문법 검증(Python에서 로컬 체크)",
    )
    p_k8s.add_argument(
        "--apply",
        action="store_true",
        help="생성 후 kubectl apply -f 로 바로 적용",
    )
    p_k8s.set_defaults(func=cmd_gen_k8s)

    # gen-heat
    p_heat = subparsers.add_parser(
        "gen-heat",
        help="Heat 템플릿 스캐폴딩 생성",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    add_common_flags(p_heat)
    p_heat.add_argument("--name", required=True, help="Heat stack 이름")
    p_heat.add_argument("--out", help="출력 파일 경로 (생략 시 stdout)")
    p_heat.add_argument(
        "--apply",
        action="store_true",
        help="생성 후 openstack stack create 로 바로 스택 생성 (--out 필수, OpenStack CLI 환경 필요)",
    )
    p_heat.set_defaults(func=cmd_gen_heat)
    return parser


def main() -> None:
    parser = build_parser()
    args = parser.parse_args()

    if not getattr(args, "command", None):
        parser.print_help()
        sys.exit(0)

    if hasattr(args, "func"):
        args.func(args)
    else:
        parser.print_help()
        sys.exit(1)


if __name__ == "__main__":
    main()
